1. Инкапсуляция - сокрытие. Ограничение доступа к полям и их изменению,
доступа к вызову функций.
Наследование - наследник получает свойства отца.
Полиморфизм - один интерфейс несколько методов.

2. Поля инициализируются в конструкторе. Значения по умолчанию null у 
объектов и свои у примитивов. Блок инициализации.

3. Конструктор без параметров, гетер сетер, сереализация, переопределение
equals, hashcode, toString.

4. Перегрузка - одноименные методы с различными параметрами. Использование
одного имени, автовызов по параметрам. Нельзя перегрузить статические методы.

5. Связывание момент вызова куска кода, раннее в момент компиляции
известно после чего что будет вызвано, позднее в момент выполнения
становиться известно что именно вызывать. Перегрузка - раннее. По
списку типов определяетнужный метод.

6. This ссылка на себя экземляр класса. Присутствует в методах где имя
параметра совпадает с внутренним полем которое используется в методе.

7. Final поле нельзя поменять после определения. В конструкторе.

8. Статическое поле определено одно для все экземпляров класса, 
финальные неизменяемые поля, статические методы связываются во время
компиляции. К статическим переменным. Перегрузить можно переопределить
нет. Не наследуется.

9. Блок заключенный в фигурные скобки, где проходит инициализация полей;
в статическом статические в логическом остальные. Размещены после определения
полей, сколько нужно, сначала статические.

10. Метод(тип ... переменная), передаются через запятую, параметр являет
массив. Если другие не подошли то используется этот.

11. Отец всех классов. Clone копия объекта, equals проверка на равенство,
hashcode почти уникальное значение по специальной формуле, tostring
перевод в массив символов.

12. Значение вычисляемое по специальной формуле. Из-за огромного числа
возможных объектов может полцчиться одинаковый хеш.

13. Наследование поведения, избавление от дубликации кода. Транспорт автомобиль.
Наследуются, но к ним нет доступа.

14. new Obj(). super вызов одноименного метода родителя. Можно.

15. Принцип полиморфизма, родитель может ссылаться на наследника. Обратное
неверно, наследник имеет свойства родителя, родитель не имеет всех свойств
наследника.

16. Метод у наследника с другим телом. Простота чтения. Нельзя. Нельзя. Нельзя.

17. Вызывается метод типа объекта, а не ссылки. Нельзя.

18. Финальный метод нельхя переопределить, финальный класс не может иметь наследников.
Логическая структуризация.

19. Сылка типа родителя может ссылаться на объект типа наследника. Так же как и в
примитивах.

20. Штука хранящая описание класса.

21. Менять только то что в фигурных скобках.

22. Классы описывающие но не определяющие логику. Конструктор определять нельзя.
Могут содержать необстрактные методы. Объект создать нельзя. Не предназначен.

23. Класс не содержащий переменых и реализаций методов. interface, implements. private
нельзя. Нельзя описать конструктор и создать объект. Ссылки ссылаются на оюъекты типа
наследника интерфейса.

24. Для возможности клонирования объекта. Проблема со ссылками и потоками.

25. Для возможности сравнения объектов. Comparable задает свойство сравнения, comparator
позволяет создать объекты для реализации сравнения. Первый нужен только один критерий для
сравнений, второ йнужно несколько. Относледоваться, переопределить метод.

1. Перечисление ограниченный круг значений. enum. Объектом класса перечисление.

2. Можно. Можно. Сравнеине через "==".

3. Внутренний класс без имени.

4. Класс где тип внутренних данных указан ввиде параметра. class Cl<T>{T ob}; Cl<Integer> c
= new Cl<Integer>(10).В ссылке можне не указывать тип. Примитивом нельзя.

1. Исключительная - ситуация при которой приложение дает неправильный результат. try catch.

2. Необрабатываемый результат выполнения кода. Выдать ответ о возникновении необрабатываемой
ситуации. Деление на ноль (наследуются от RunTimeException) непроверяемые, проверяемые
необходимо самому описывать try catch.

3. RunTimeException Error непроверяемые, остальное проверяемое. Нужда в описании.

4. В try блок кода где может выскочить ошибка, catch -обработка рпеделенной ошибки, finally
всегда отрабатывает если указан. Когда ожидается ошибка и её нельзя предупредить. Много. 
Вкладывать можно. Идет по внешним пока не найдется. Набор вложенных блоков.

5. По иерархии. Не может. При вложенности.

6. В конце. Всегда вызывается. Нет. Нет.
